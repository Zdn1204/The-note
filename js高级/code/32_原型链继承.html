<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 

        方式一：原型链继承
            套路：
                1，定义父类型构造函数
                2，给父类型的原型添加方法
                3，定义子类型的构造函数
                4，创建父类型的对象赋值给子类型的原型
                5，将子类型的原型构造属性设置为子类型
                6，给子类型原型添加方法
                7，创建子类型的对象：可以调用父类型的方法
            关键：
                1，子类型的原型为父类型的一个实例对象
     -->

    <script>

        //父类型
        function Supper(){
            this.supPro = 'Supper property';
        }
        Supper.prototype.showSupperProp = function(){
            console.log(this.supPro);
        }

        //子类型
        function Sub(){
            this.subPro = 'Sub proterty';
        }

        //子类型的原型为父类型的一个实例对象
        Sub.prototype = new Supper();
        //让子类型的原型的constructor指向子类型
        Sub.prototype.constructor = Sub;

        Sub.prototype.showSubProp = function(){
            console.log(this.subProp);
        }

        var sub = new Sub();
        sub.showSupperProp();
        sub.toSting();
    </script>

    <!-- 

        方式二：借用构造函数继承（假的）
            套路：
                1，定义父类型构造函数
                2，定义子类型构造函数
                3，在子类型构造函数中调用父类型构造
            关键：
                1，在子类型构造函数中通用call()调用父类型构造函数
     -->

     <script>

        function Person(name, age){
            this.name = name;
            this.age = age;
        }

        function Student(name, age, price){
            Person.call(this, name, age);
            this.price = price;
        }
    </script>
</body>
</html>